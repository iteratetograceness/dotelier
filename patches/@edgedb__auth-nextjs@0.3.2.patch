diff --git a/dist/app/index.d.ts b/dist/app/index.d.ts
index 73a2aed10ec855c39f13253304bf8860f1f73b50..675d23625a84824e1fce5b4f2e9536fc07c68463 100644
--- a/dist/app/index.d.ts
+++ b/dist/app/index.d.ts
@@ -1,38 +1,82 @@
-import { type TokenData } from "@edgedb/auth-core";
-import type { Client } from "edgedb";
-import { NextAuth, NextAuthSession, type NextAuthOptions, type BuiltinProviderNames, type CreateAuthRouteHandlers } from "../shared";
-export * from "@edgedb/auth-core/errors";
-export { NextAuthSession, type NextAuthOptions, type BuiltinProviderNames, type TokenData, type CreateAuthRouteHandlers, };
+import { type TokenData } from '@edgedb/auth-core'
+import type { Client } from 'edgedb'
+import {
+  NextAuth,
+  NextAuthSession,
+  type NextAuthOptions,
+  type BuiltinProviderNames,
+  type CreateAuthRouteHandlers,
+} from '../shared'
+export * from '@edgedb/auth-core/errors'
+export {
+  NextAuthSession,
+  type NextAuthOptions,
+  type BuiltinProviderNames,
+  type TokenData,
+  type CreateAuthRouteHandlers,
+}
 export declare class NextAppAuth extends NextAuth {
-    getSession: () => NextAuthSession;
-    createServerActions(): {
-        signout: () => Promise<void>;
-        emailPasswordSignIn: (data: FormData | {
-            email: string;
-            password: string;
-        }) => Promise<TokenData>;
-        emailPasswordSignUp: (data: FormData | {
-            email: string;
-            password: string;
-        }) => Promise<TokenData | null>;
-        emailPasswordSendPasswordResetEmail: (data: FormData | {
-            email: string;
-        }) => Promise<void>;
-        emailPasswordResetPassword: (data: FormData | {
-            reset_token: string;
-            password: string;
-        }) => Promise<TokenData>;
-        emailPasswordResendVerificationEmail: (data: FormData | {
-            verification_token: string;
-        } | {
-            email: string;
-        }) => Promise<void>;
-        magicLinkSignUp: (data: FormData | {
-            email: string;
-        }) => Promise<void>;
-        magicLinkSignIn: (data: FormData | {
-            email: string;
-        }) => Promise<void>;
-    };
+  getSession: () => Promise<NextAuthSession>
+  createServerActions(): {
+    signout: () => Promise<void>
+    emailPasswordSignIn: (
+      data:
+        | FormData
+        | {
+            email: string
+            password: string
+          }
+    ) => Promise<TokenData>
+    emailPasswordSignUp: (
+      data:
+        | FormData
+        | {
+            email: string
+            password: string
+          }
+    ) => Promise<TokenData | null>
+    emailPasswordSendPasswordResetEmail: (
+      data:
+        | FormData
+        | {
+            email: string
+          }
+    ) => Promise<void>
+    emailPasswordResetPassword: (
+      data:
+        | FormData
+        | {
+            reset_token: string
+            password: string
+          }
+    ) => Promise<TokenData>
+    emailPasswordResendVerificationEmail: (
+      data:
+        | FormData
+        | {
+            verification_token: string
+          }
+        | {
+            email: string
+          }
+    ) => Promise<void>
+    magicLinkSignUp: (
+      data:
+        | FormData
+        | {
+            email: string
+          }
+    ) => Promise<void>
+    magicLinkSignIn: (
+      data:
+        | FormData
+        | {
+            email: string
+          }
+    ) => Promise<void>
+  }
 }
-export default function createNextAppAuth(client: Client, options: NextAuthOptions): NextAppAuth;
+export default function createNextAppAuth(
+  client: Client,
+  options: NextAuthOptions
+): NextAppAuth
diff --git a/dist/app/index.js b/dist/app/index.js
index e454d007edc361af26f919128bbc668a36ae658f..299d2a97c3bd0b211bf93887bf26a812709dd357 100644
--- a/dist/app/index.js
+++ b/dist/app/index.js
@@ -1,116 +1,222 @@
-"use strict";
-var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
-    if (k2 === undefined) k2 = k;
-    var desc = Object.getOwnPropertyDescriptor(m, k);
-    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
-      desc = { enumerable: true, get: function() { return m[k]; } };
-    }
-    Object.defineProperty(o, k2, desc);
-}) : (function(o, m, k, k2) {
-    if (k2 === undefined) k2 = k;
-    o[k2] = m[k];
-}));
-var __exportStar = (this && this.__exportStar) || function(m, exports) {
-    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.NextAppAuth = exports.NextAuthSession = void 0;
-exports.default = createNextAppAuth;
-const auth_core_1 = require("@edgedb/auth-core");
-const headers_1 = require("next/headers");
-const react_1 = require("react");
-const shared_1 = require("../shared");
-Object.defineProperty(exports, "NextAuthSession", { enumerable: true, get: function () { return shared_1.NextAuthSession; } });
-__exportStar(require("@edgedb/auth-core/errors"), exports);
-class NextAppAuth extends shared_1.NextAuth {
-    getSession = (0, react_1.cache)(() => new shared_1.NextAuthSession(this.client, (0, headers_1.cookies)().get(this.options.authCookieName)?.value.split(";")[0] ?? null));
-    createServerActions() {
-        return {
-            signout: async () => {
-                (0, headers_1.cookies)().delete(this.options.authCookieName);
-            },
-            emailPasswordSignIn: async (data) => {
-                const [email, password] = (0, shared_1._extractParams)(data, ["email", "password"], "email or password missing");
-                const tokenData = await (await this.core).signinWithEmailPassword(email, password);
-                this.setAuthCookie(tokenData.auth_token);
-                return tokenData;
-            },
-            emailPasswordSignUp: async (data) => {
-                const [email, password] = (0, shared_1._extractParams)(data, ["email", "password"], "email or password missing");
-                const result = await (await this.core).signupWithEmailPassword(email, password, `${this._authRoute}/emailpassword/verify`);
-                this.setVerifierCookie(result.verifier);
-                if (result.status === "complete") {
-                    this.setAuthCookie(result.tokenData.auth_token);
-                    return result.tokenData;
-                }
-                return null;
-            },
-            emailPasswordSendPasswordResetEmail: async (data) => {
-                if (!this.options.passwordResetPath) {
-                    throw new auth_core_1.ConfigurationError(`'passwordResetPath' option not configured`);
-                }
-                const [email] = (0, shared_1._extractParams)(data, ["email"], "email missing");
-                const { verifier } = await (await this.core).sendPasswordResetEmail(email, new URL(this.options.passwordResetPath, this.options.baseUrl).toString());
-                this.setVerifierCookie(verifier);
+'use strict'
+var __createBinding =
+  (this && this.__createBinding) ||
+  (Object.create
+    ? function (o, m, k, k2) {
+        if (k2 === undefined) k2 = k
+        var desc = Object.getOwnPropertyDescriptor(m, k)
+        if (
+          !desc ||
+          ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)
+        ) {
+          desc = {
+            enumerable: true,
+            get: function () {
+              return m[k]
             },
-            emailPasswordResetPassword: async (data) => {
-                const verifier = (0, headers_1.cookies)().get(this.options.pkceVerifierCookieName)?.value;
-                if (!verifier) {
-                    throw new auth_core_1.PKCEError("no pkce verifier cookie found");
-                }
-                const [resetToken, password] = (0, shared_1._extractParams)(data, ["reset_token", "password"], "reset_token or password missing");
-                const tokenData = await (await this.core).resetPasswordWithResetToken(resetToken, verifier, password);
-                this.setAuthCookie(tokenData.auth_token);
-                (0, headers_1.cookies)().delete(this.options.pkceVerifierCookieName);
-                return tokenData;
-            },
-            emailPasswordResendVerificationEmail: async (data) => {
-                const verificationToken = data instanceof FormData
-                    ? data.get("verification_token")
-                    : "verification_token" in data
-                        ? data.verification_token
-                        : null;
-                const email = data instanceof FormData
-                    ? data.get("email")
-                    : "email" in data
-                        ? data.email
-                        : null;
-                if (verificationToken) {
-                    await (await this.core).resendVerificationEmail(verificationToken.toString());
-                }
-                else if (email) {
-                    const { verifier } = await (await this.core).resendVerificationEmailForEmail(email.toString(), `${this._authRoute}/emailpassword/verify`);
-                    (0, headers_1.cookies)().set({
-                        name: this.options.pkceVerifierCookieName,
-                        value: verifier,
-                        httpOnly: true,
-                        sameSite: "strict",
-                    });
-                }
-                else {
-                    throw new auth_core_1.InvalidDataError("either verification_token or email must be provided");
-                }
-            },
-            magicLinkSignUp: async (data) => {
-                if (!this.options.magicLinkFailurePath) {
-                    throw new auth_core_1.ConfigurationError(`'magicLinkFailurePath' option not configured`);
-                }
-                const [email] = (0, shared_1._extractParams)(data, ["email"], "email missing");
-                const { verifier } = await (await this.core).signupWithMagicLink(email, `${this._authRoute}/magiclink/callback?isSignUp=true`, new URL(this.options.magicLinkFailurePath, this.options.baseUrl).toString());
-                this.setVerifierCookie(verifier);
-            },
-            magicLinkSignIn: async (data) => {
-                if (!this.options.magicLinkFailurePath) {
-                    throw new auth_core_1.ConfigurationError(`'magicLinkFailurePath' option not configured`);
-                }
-                const [email] = (0, shared_1._extractParams)(data, ["email"], "email missing");
-                const { verifier } = await (await this.core).signinWithMagicLink(email, `${this._authRoute}/magiclink/callback`, new URL(this.options.magicLinkFailurePath, this.options.baseUrl).toString());
-                this.setVerifierCookie(verifier);
-            },
-        };
+          }
+        }
+        Object.defineProperty(o, k2, desc)
+      }
+    : function (o, m, k, k2) {
+        if (k2 === undefined) k2 = k
+        o[k2] = m[k]
+      })
+var __exportStar =
+  (this && this.__exportStar) ||
+  function (m, exports) {
+    for (var p in m)
+      if (p !== 'default' && !Object.prototype.hasOwnProperty.call(exports, p))
+        __createBinding(exports, m, p)
+  }
+Object.defineProperty(exports, '__esModule', { value: true })
+exports.NextAppAuth = exports.NextAuthSession = void 0
+exports.default = createNextAppAuth
+const auth_core_1 = require('@edgedb/auth-core')
+const headers_1 = require('next/headers')
+const react_1 = require('react')
+const shared_1 = require('../shared')
+Object.defineProperty(exports, 'NextAuthSession', {
+  enumerable: true,
+  get: function () {
+    return shared_1.NextAuthSession
+  },
+})
+__exportStar(require('@edgedb/auth-core/errors'), exports)
+class NextAppAuth extends shared_1.NextAuth {
+  getSession = (0, react_1.cache)(async () => {
+    const cookies = await (0, headers_1.cookies)()
+    const cookie = cookies.get(this.options.authCookieName)
+    return new shared_1.NextAuthSession(
+      this.client,
+      cookie?.value.split(';')[0] ?? null
+    )
+  })
+  createServerActions() {
+    return {
+      signout: async () => {
+        const cookies = await (0, headers_1.cookies)()
+        cookies.delete(this.options.authCookieName)
+      },
+      emailPasswordSignIn: async (data) => {
+        const [email, password] = (0, shared_1._extractParams)(
+          data,
+          ['email', 'password'],
+          'email or password missing'
+        )
+        const tokenData = await (
+          await this.core
+        ).signinWithEmailPassword(email, password)
+        await this.setAuthCookie(tokenData.auth_token)
+        return tokenData
+      },
+      emailPasswordSignUp: async (data) => {
+        const [email, password] = (0, shared_1._extractParams)(
+          data,
+          ['email', 'password'],
+          'email or password missing'
+        )
+        const result = await (
+          await this.core
+        ).signupWithEmailPassword(
+          email,
+          password,
+          `${this._authRoute}/emailpassword/verify`
+        )
+        await this.setVerifierCookie(result.verifier)
+        if (result.status === 'complete') {
+          await this.setAuthCookie(result.tokenData.auth_token)
+          return result.tokenData
+        }
+        return null
+      },
+      emailPasswordSendPasswordResetEmail: async (data) => {
+        if (!this.options.passwordResetPath) {
+          throw new auth_core_1.ConfigurationError(
+            `'passwordResetPath' option not configured`
+          )
+        }
+        const [email] = (0, shared_1._extractParams)(
+          data,
+          ['email'],
+          'email missing'
+        )
+        const { verifier } = await (
+          await this.core
+        ).sendPasswordResetEmail(
+          email,
+          new URL(
+            this.options.passwordResetPath,
+            this.options.baseUrl
+          ).toString()
+        )
+        await this.setVerifierCookie(verifier)
+      },
+      emailPasswordResetPassword: async (data) => {
+        const verifier = (0, headers_1.cookies)().get(
+          this.options.pkceVerifierCookieName
+        )?.value
+        if (!verifier) {
+          throw new auth_core_1.PKCEError('no pkce verifier cookie found')
+        }
+        const [resetToken, password] = (0, shared_1._extractParams)(
+          data,
+          ['reset_token', 'password'],
+          'reset_token or password missing'
+        )
+        const tokenData = await (
+          await this.core
+        ).resetPasswordWithResetToken(resetToken, verifier, password)
+        await this.setAuthCookie(tokenData.auth_token)
+        ;(0, headers_1.cookies)().delete(this.options.pkceVerifierCookieName)
+        return tokenData
+      },
+      emailPasswordResendVerificationEmail: async (data) => {
+        const verificationToken =
+          data instanceof FormData
+            ? data.get('verification_token')
+            : 'verification_token' in data
+            ? data.verification_token
+            : null
+        const email =
+          data instanceof FormData
+            ? data.get('email')
+            : 'email' in data
+            ? data.email
+            : null
+        if (verificationToken) {
+          await (
+            await this.core
+          ).resendVerificationEmail(verificationToken.toString())
+        } else if (email) {
+          const { verifier } = await (
+            await this.core
+          ).resendVerificationEmailForEmail(
+            email.toString(),
+            `${this._authRoute}/emailpassword/verify`
+          )
+          ;(0, headers_1.cookies)().set({
+            name: this.options.pkceVerifierCookieName,
+            value: verifier,
+            httpOnly: true,
+            sameSite: 'strict',
+          })
+        } else {
+          throw new auth_core_1.InvalidDataError(
+            'either verification_token or email must be provided'
+          )
+        }
+      },
+      magicLinkSignUp: async (data) => {
+        if (!this.options.magicLinkFailurePath) {
+          throw new auth_core_1.ConfigurationError(
+            `'magicLinkFailurePath' option not configured`
+          )
+        }
+        const [email] = (0, shared_1._extractParams)(
+          data,
+          ['email'],
+          'email missing'
+        )
+        const { verifier } = await (
+          await this.core
+        ).signupWithMagicLink(
+          email,
+          `${this._authRoute}/magiclink/callback?isSignUp=true`,
+          new URL(
+            this.options.magicLinkFailurePath,
+            this.options.baseUrl
+          ).toString()
+        )
+        await this.setVerifierCookie(verifier)
+      },
+      magicLinkSignIn: async (data) => {
+        if (!this.options.magicLinkFailurePath) {
+          throw new auth_core_1.ConfigurationError(
+            `'magicLinkFailurePath' option not configured`
+          )
+        }
+        const [email] = (0, shared_1._extractParams)(
+          data,
+          ['email'],
+          'email missing'
+        )
+        const { verifier } = await (
+          await this.core
+        ).signinWithMagicLink(
+          email,
+          `${this._authRoute}/magiclink/callback`,
+          new URL(
+            this.options.magicLinkFailurePath,
+            this.options.baseUrl
+          ).toString()
+        )
+        await this.setVerifierCookie(verifier)
+      },
     }
+  }
 }
-exports.NextAppAuth = NextAppAuth;
+exports.NextAppAuth = NextAppAuth
 function createNextAppAuth(client, options) {
-    return new NextAppAuth(client, options);
+  return new NextAppAuth(client, options)
 }
diff --git a/dist/shared.d.ts b/dist/shared.d.ts
index f974439779ef163375629351d007c118cfbecab1..0049864512270c2a7855f3351d141027cb7b8607 100644
--- a/dist/shared.d.ts
+++ b/dist/shared.d.ts
@@ -1,91 +1,168 @@
-import { type Client } from "edgedb";
-import { Auth, type BuiltinOAuthProviderNames, type TokenData, type SignupResponse } from "@edgedb/auth-core";
-import { type BuiltinProviderNames, NextAuthHelpers, type NextAuthOptions } from "./shared.client";
-import type { NextRequest, NextResponse } from "next/server";
-export { type BuiltinProviderNames, NextAuthHelpers, type NextAuthOptions };
-type ParamsOrError<Result extends object, ErrorDetails extends object = object> = ({
-    error: null;
-} & {
-    [Key in keyof ErrorDetails]?: undefined;
-} & Result) | ({
-    error: Error;
-} & ErrorDetails & {
-    [Key in keyof Result]?: undefined;
-});
+import { type Client } from 'edgedb'
+import {
+  Auth,
+  type BuiltinOAuthProviderNames,
+  type TokenData,
+  type SignupResponse,
+} from '@edgedb/auth-core'
+import {
+  type BuiltinProviderNames,
+  NextAuthHelpers,
+  type NextAuthOptions,
+} from './shared.client'
+import type { NextRequest, NextResponse } from 'next/server'
+export { type BuiltinProviderNames, NextAuthHelpers, type NextAuthOptions }
+type ParamsOrError<
+  Result extends object,
+  ErrorDetails extends object = object
+> =
+  | ({
+      error: null
+    } & {
+      [Key in keyof ErrorDetails]?: undefined
+    } & Result)
+  | ({
+      error: Error
+    } & ErrorDetails & {
+        [Key in keyof Result]?: undefined
+      })
 export interface CreateAuthRouteHandlers {
-    onOAuthCallback(params: ParamsOrError<{
-        tokenData: TokenData;
-        provider: BuiltinOAuthProviderNames;
-        isSignUp: boolean;
-    }>, req: NextRequest): Promise<never>;
-    onEmailPasswordSignIn(params: ParamsOrError<{
-        tokenData: TokenData;
-    }>, req: NextRequest): Promise<Response>;
-    onEmailPasswordSignUp(params: ParamsOrError<{
-        tokenData: TokenData | null;
-    }>, req: NextRequest): Promise<Response>;
-    onEmailPasswordReset(params: ParamsOrError<{
-        tokenData: TokenData;
-    }>, req: NextRequest): Promise<Response>;
-    onEmailVerify(params: ParamsOrError<{
-        tokenData: TokenData;
-    }, {
-        verificationToken?: string;
-    }>, req: NextRequest): Promise<never>;
-    onWebAuthnSignUp(params: ParamsOrError<{
-        tokenData: TokenData | null;
-    }>, req: NextRequest): Promise<NextResponse<SignupResponse>>;
-    onWebAuthnSignIn(params: ParamsOrError<{
-        tokenData: TokenData;
-    }>, req: NextRequest): Promise<never>;
-    onMagicLinkCallback(params: ParamsOrError<{
-        tokenData: TokenData;
-        isSignUp: boolean;
-    }>, req: NextRequest): Promise<never>;
-    onMagicLinkSignIn(params: ParamsOrError<{
-        tokenData: TokenData;
-    }>, req: NextRequest): Promise<never>;
-    onBuiltinUICallback(params: ParamsOrError<({
-        tokenData: TokenData;
-        provider: BuiltinProviderNames;
-    } | {
-        tokenData: null;
-        provider: null;
-    }) & {
-        isSignUp: boolean;
-    }>, req: NextRequest): Promise<never>;
-    onSignout(req: NextRequest): Promise<never>;
+  onOAuthCallback(
+    params: ParamsOrError<{
+      tokenData: TokenData
+      provider: BuiltinOAuthProviderNames
+      isSignUp: boolean
+    }>,
+    req: NextRequest
+  ): Promise<never>
+  onEmailPasswordSignIn(
+    params: ParamsOrError<{
+      tokenData: TokenData
+    }>,
+    req: NextRequest
+  ): Promise<Response>
+  onEmailPasswordSignUp(
+    params: ParamsOrError<{
+      tokenData: TokenData | null
+    }>,
+    req: NextRequest
+  ): Promise<Response>
+  onEmailPasswordReset(
+    params: ParamsOrError<{
+      tokenData: TokenData
+    }>,
+    req: NextRequest
+  ): Promise<Response>
+  onEmailVerify(
+    params: ParamsOrError<
+      {
+        tokenData: TokenData
+      },
+      {
+        verificationToken?: string
+      }
+    >,
+    req: NextRequest
+  ): Promise<never>
+  onWebAuthnSignUp(
+    params: ParamsOrError<{
+      tokenData: TokenData | null
+    }>,
+    req: NextRequest
+  ): Promise<NextResponse<SignupResponse>>
+  onWebAuthnSignIn(
+    params: ParamsOrError<{
+      tokenData: TokenData
+    }>,
+    req: NextRequest
+  ): Promise<never>
+  onMagicLinkCallback(
+    params: ParamsOrError<{
+      tokenData: TokenData
+      isSignUp: boolean
+    }>,
+    req: NextRequest
+  ): Promise<never>
+  onMagicLinkSignIn(
+    params: ParamsOrError<{
+      tokenData: TokenData
+    }>,
+    req: NextRequest
+  ): Promise<never>
+  onBuiltinUICallback(
+    params: ParamsOrError<
+      (
+        | {
+            tokenData: TokenData
+            provider: BuiltinProviderNames
+          }
+        | {
+            tokenData: null
+            provider: null
+          }
+      ) & {
+        isSignUp: boolean
+      }
+    >,
+    req: NextRequest
+  ): Promise<never>
+  onSignout(req: NextRequest): Promise<never>
 }
 export declare abstract class NextAuth extends NextAuthHelpers {
-    protected readonly client: Client;
-    protected readonly core: Promise<Auth>;
-    getProvidersInfo(): Promise<{
-        oauth: {
-            name: BuiltinOAuthProviderNames;
-            display_name: string;
-        }[];
-        emailPassword: boolean;
-    }>;
-    isPasswordResetTokenValid(resetToken: string): boolean | null;
-    setVerifierCookie(verifier: string): void;
-    setAuthCookie(token: string): void;
-    createAuthRouteHandlers({ onOAuthCallback, onEmailPasswordSignIn, onEmailPasswordSignUp, onEmailPasswordReset, onEmailVerify, onWebAuthnSignUp, onWebAuthnSignIn, onMagicLinkCallback, onBuiltinUICallback, onSignout, }: Partial<CreateAuthRouteHandlers>): {
-        GET: (req: NextRequest, { params }: {
-            params: {
-                auth: string[];
-            };
-        }) => Promise<Response>;
-        POST: (req: NextRequest, { params }: {
-            params: {
-                auth: string[];
-            };
-        }) => Promise<Response | undefined>;
-    };
+  protected readonly client: Client
+  protected readonly core: Promise<Auth>
+  getProvidersInfo(): Promise<{
+    oauth: {
+      name: BuiltinOAuthProviderNames
+      display_name: string
+    }[]
+    emailPassword: boolean
+  }>
+  isPasswordResetTokenValid(resetToken: string): boolean | null
+  setVerifierCookie(verifier: string): Promise<void>
+  setAuthCookie(token: string): Promise<void>
+  createAuthRouteHandlers({
+    onOAuthCallback,
+    onEmailPasswordSignIn,
+    onEmailPasswordSignUp,
+    onEmailPasswordReset,
+    onEmailVerify,
+    onWebAuthnSignUp,
+    onWebAuthnSignIn,
+    onMagicLinkCallback,
+    onBuiltinUICallback,
+    onSignout,
+  }: Partial<CreateAuthRouteHandlers>): {
+    GET: (
+      req: NextRequest,
+      {
+        params,
+      }: {
+        params: {
+          auth: string[]
+        }
+      }
+    ) => Promise<Response>
+    POST: (
+      req: NextRequest,
+      {
+        params,
+      }: {
+        params: {
+          auth: string[]
+        }
+      }
+    ) => Promise<Response | undefined>
+  }
 }
 export declare class NextAuthSession {
-    readonly authToken: string | null;
-    readonly client: Client;
-    private _isSignedIn;
-    isSignedIn(): Promise<boolean>;
+  readonly authToken: string | null
+  readonly client: Client
+  private _isSignedIn
+  isSignedIn(): Promise<boolean>
 }
-export declare function _extractParams(data: FormData | Record<string, unknown>, paramNames: string[], errMessage: string): string[];
+export declare function _extractParams(
+  data: FormData | Record<string, unknown>,
+  paramNames: string[],
+  errMessage: string
+): string[]
diff --git a/dist/shared.js b/dist/shared.js
index 8383898787e1ffca962e6668bc0667c169a986d9..f88e9431bd2c4d098bb05fa824ff88cd52a7dc59 100644
--- a/dist/shared.js
+++ b/dist/shared.js
@@ -1,574 +1,857 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.NextAuthSession = exports.NextAuth = exports.NextAuthHelpers = void 0;
-exports._extractParams = _extractParams;
-const auth_core_1 = require("@edgedb/auth-core");
-const shared_client_1 = require("./shared.client");
-Object.defineProperty(exports, "NextAuthHelpers", { enumerable: true, get: function () { return shared_client_1.NextAuthHelpers; } });
-const headers_1 = require("next/headers");
-const navigation_1 = require("next/navigation");
+'use strict'
+Object.defineProperty(exports, '__esModule', { value: true })
+exports.NextAuthSession = exports.NextAuth = exports.NextAuthHelpers = void 0
+exports._extractParams = _extractParams
+const auth_core_1 = require('@edgedb/auth-core')
+const shared_client_1 = require('./shared.client')
+Object.defineProperty(exports, 'NextAuthHelpers', {
+  enumerable: true,
+  get: function () {
+    return shared_client_1.NextAuthHelpers
+  },
+})
+const headers_1 = require('next/headers')
+const navigation_1 = require('next/navigation')
 class NextAuth extends shared_client_1.NextAuthHelpers {
-    client;
-    core;
-    constructor(client, options) {
-        super(options);
-        this.client = client;
-        this.core = auth_core_1.Auth.create(client);
-    }
-    async getProvidersInfo() {
-        return (await this.core).getProvidersInfo();
-    }
-    isPasswordResetTokenValid(resetToken) {
-        return auth_core_1.Auth.checkPasswordResetTokenValid(resetToken);
-    }
-    setVerifierCookie(verifier) {
-        (0, headers_1.cookies)().set({
-            name: this.options.pkceVerifierCookieName,
-            value: verifier,
-            httpOnly: true,
-            path: "/",
-            sameSite: "lax",
-            secure: this.isSecure,
-            expires: Date.now() + 1000 * 60 * 60 * 24 * 7,
-        });
-    }
-    setAuthCookie(token) {
-        const expirationDate = auth_core_1.Auth.getTokenExpiration(token);
-        (0, headers_1.cookies)().set({
-            name: this.options.authCookieName,
-            value: token,
-            httpOnly: true,
-            sameSite: "lax",
-            path: "/",
-            secure: this.isSecure,
-            expires: expirationDate ?? undefined,
-        });
-    }
-    createAuthRouteHandlers({ onOAuthCallback, onEmailPasswordSignIn, onEmailPasswordSignUp, onEmailPasswordReset, onEmailVerify, onWebAuthnSignUp, onWebAuthnSignIn, onMagicLinkCallback, onBuiltinUICallback, onSignout, }) {
-        return {
-            GET: async (req, { params }) => {
-                switch (params.auth.join("/")) {
-                    case "oauth": {
-                        if (!onOAuthCallback) {
-                            throw new auth_core_1.ConfigurationError(`'onOAuthCallback' auth route handler not configured`);
-                        }
-                        const provider = req.nextUrl.searchParams.get("provider_name");
-                        if (!provider || !auth_core_1.builtinOAuthProviderNames.includes(provider)) {
-                            throw new auth_core_1.InvalidDataError(`invalid provider_name: ${provider}`);
-                        }
-                        const redirectUrl = `${this._authRoute}/oauth/callback`;
-                        const pkceSession = await this.core.then((core) => core.createPKCESession());
-                        this.setVerifierCookie(pkceSession.verifier);
-                        return (0, navigation_1.redirect)(pkceSession.getOAuthUrl(provider, redirectUrl, `${redirectUrl}?isSignUp=true`));
-                    }
-                    case "oauth/callback": {
-                        if (!onOAuthCallback) {
-                            throw new auth_core_1.ConfigurationError(`'onOAuthCallback' auth route handler not configured`);
-                        }
-                        const error = req.nextUrl.searchParams.get("error");
-                        if (error) {
-                            const desc = req.nextUrl.searchParams.get("error_description");
-                            return onOAuthCallback({
-                                error: new auth_core_1.OAuthProviderFailureError(error + (desc ? `: ${desc}` : "")),
-                            }, req);
-                        }
-                        const code = req.nextUrl.searchParams.get("code");
-                        const isSignUp = req.nextUrl.searchParams.get("isSignUp") === "true";
-                        const verifier = req.cookies.get(this.options.pkceVerifierCookieName)?.value;
-                        if (!code) {
-                            return onOAuthCallback({
-                                error: new auth_core_1.PKCEError("no pkce code in response"),
-                            }, req);
-                        }
-                        if (!verifier) {
-                            return onOAuthCallback({
-                                error: new auth_core_1.PKCEError("no pkce verifier cookie found"),
-                            }, req);
-                        }
-                        let tokenData;
-                        try {
-                            tokenData = await (await this.core).getToken(code, verifier);
-                        }
-                        catch (err) {
-                            return onOAuthCallback({
-                                error: err instanceof Error ? err : new Error(String(err)),
-                            }, req);
-                        }
-                        this.setAuthCookie(tokenData.auth_token);
-                        (0, headers_1.cookies)().delete(this.options.pkceVerifierCookieName);
-                        return onOAuthCallback({
-                            error: null,
-                            tokenData,
-                            provider: req.nextUrl.searchParams.get("provider"),
-                            isSignUp,
-                        }, req);
-                    }
-                    case "emailpassword/verify": {
-                        if (!onEmailVerify) {
-                            throw new auth_core_1.ConfigurationError(`'onEmailVerify' auth route handler not configured`);
-                        }
-                        const verificationToken = req.nextUrl.searchParams.get("verification_token");
-                        const verifier = req.cookies.get(this.options.pkceVerifierCookieName)?.value;
-                        if (!verificationToken) {
-                            return onEmailVerify({
-                                error: new auth_core_1.PKCEError("no verification_token in response"),
-                            }, req);
-                        }
-                        if (!verifier) {
-                            return onEmailVerify({
-                                error: new auth_core_1.PKCEError("no pkce verifier cookie found"),
-                                verificationToken,
-                            }, req);
-                        }
-                        let tokenData;
-                        try {
-                            tokenData = await (await this.core).verifyEmailPasswordSignup(verificationToken, verifier);
-                        }
-                        catch (err) {
-                            return onEmailVerify({
-                                error: err instanceof Error ? err : new Error(String(err)),
-                                verificationToken,
-                            }, req);
-                        }
-                        this.setAuthCookie(tokenData.auth_token);
-                        (0, headers_1.cookies)().delete(this.options.pkceVerifierCookieName);
-                        return onEmailVerify({ error: null, tokenData }, req);
-                    }
-                    case "webauthn/signup/options": {
-                        const email = req.nextUrl.searchParams.get("email");
-                        if (!email) {
-                            throw new auth_core_1.InvalidDataError("'email' is missing in request search parameters");
-                        }
-                        return Response.redirect((await this.core).getWebAuthnSignupOptionsUrl(email));
-                    }
-                    case "webauthn/signin/options": {
-                        const email = req.nextUrl.searchParams.get("email");
-                        if (!email) {
-                            throw new auth_core_1.InvalidDataError("'email' is missing in request search parameters");
-                        }
-                        return Response.redirect((await this.core).getWebAuthnSigninOptionsUrl(email));
-                    }
-                    case "webauthn/verify": {
-                        if (!onEmailVerify) {
-                            throw new auth_core_1.ConfigurationError(`'onEmailVerify' auth route handler not configured`);
-                        }
-                        const verificationToken = req.nextUrl.searchParams.get("verification_token");
-                        const verifier = req.cookies.get(this.options.pkceVerifierCookieName)?.value;
-                        if (!verificationToken) {
-                            return onEmailVerify({
-                                error: new auth_core_1.PKCEError("no verification_token in response"),
-                            }, req);
-                        }
-                        if (!verifier) {
-                            return onEmailVerify({
-                                error: new auth_core_1.PKCEError("no pkce verifier cookie found"),
-                                verificationToken,
-                            }, req);
-                        }
-                        let tokenData;
-                        try {
-                            tokenData = await (await this.core).verifyWebAuthnSignup(verificationToken, verifier);
-                        }
-                        catch (err) {
-                            return onEmailVerify({
-                                error: err instanceof Error ? err : new Error(String(err)),
-                                verificationToken,
-                            }, req);
-                        }
-                        this.setAuthCookie(tokenData.auth_token);
-                        (0, headers_1.cookies)().delete(this.options.pkceVerifierCookieName);
-                        return onEmailVerify({ error: null, tokenData }, req);
-                    }
-                    case "magiclink/callback": {
-                        if (!onMagicLinkCallback) {
-                            throw new auth_core_1.ConfigurationError(`'onMagicLinkCallback' auth route handler not configured`);
-                        }
-                        const error = req.nextUrl.searchParams.get("error");
-                        if (error) {
-                            const desc = req.nextUrl.searchParams.get("error_description");
-                            return onMagicLinkCallback({
-                                error: new auth_core_1.OAuthProviderFailureError(error + (desc ? `: ${desc}` : "")),
-                            }, req);
-                        }
-                        const code = req.nextUrl.searchParams.get("code");
-                        const isSignUp = req.nextUrl.searchParams.get("isSignUp") === "true";
-                        const verifier = req.cookies.get(this.options.pkceVerifierCookieName)?.value;
-                        if (!code) {
-                            return onMagicLinkCallback({
-                                error: new auth_core_1.PKCEError("no pkce code in response"),
-                            }, req);
-                        }
-                        if (!verifier) {
-                            return onMagicLinkCallback({
-                                error: new auth_core_1.PKCEError("no pkce verifier cookie found"),
-                            }, req);
-                        }
-                        let tokenData;
-                        try {
-                            tokenData = await (await this.core).getToken(code, verifier);
-                        }
-                        catch (err) {
-                            return onMagicLinkCallback({
-                                error: err instanceof Error ? err : new Error(String(err)),
-                            }, req);
-                        }
-                        this.setAuthCookie(tokenData.auth_token);
-                        (0, headers_1.cookies)().delete(this.options.pkceVerifierCookieName);
-                        return onMagicLinkCallback({
-                            error: null,
-                            tokenData,
-                            isSignUp,
-                        }, req);
-                    }
-                    case "builtin/callback": {
-                        if (!onBuiltinUICallback) {
-                            throw new auth_core_1.ConfigurationError(`'onBuiltinUICallback' auth route handler not configured`);
-                        }
-                        const error = req.nextUrl.searchParams.get("error");
-                        if (error) {
-                            const desc = req.nextUrl.searchParams.get("error_description");
-                            return onBuiltinUICallback({
-                                error: new auth_core_1.EdgeDBAuthError(error + (desc ? `: ${desc}` : "")),
-                            }, req);
-                        }
-                        const code = req.nextUrl.searchParams.get("code");
-                        const verificationEmailSentAt = req.nextUrl.searchParams.get("verification_email_sent_at");
-                        if (!code) {
-                            if (verificationEmailSentAt) {
-                                return onBuiltinUICallback({
-                                    error: null,
-                                    tokenData: null,
-                                    provider: null,
-                                    isSignUp: true,
-                                }, req);
-                            }
-                            return onBuiltinUICallback({
-                                error: new auth_core_1.PKCEError("no pkce code in response"),
-                            }, req);
-                        }
-                        const verifier = req.cookies.get(this.options.pkceVerifierCookieName)?.value;
-                        if (!verifier) {
-                            return onBuiltinUICallback({
-                                error: new auth_core_1.PKCEError("no pkce verifier cookie found"),
-                            }, req);
-                        }
-                        const isSignUp = req.nextUrl.searchParams.get("isSignUp") === "true";
-                        let tokenData;
-                        try {
-                            tokenData = await (await this.core).getToken(code, verifier);
-                        }
-                        catch (err) {
-                            return onBuiltinUICallback({
-                                error: err instanceof Error ? err : new Error(String(err)),
-                            }, req);
-                        }
-                        this.setAuthCookie(tokenData.auth_token);
-                        return onBuiltinUICallback({
-                            error: null,
-                            tokenData,
-                            provider: req.nextUrl.searchParams.get("provider"),
-                            isSignUp,
-                        }, req);
-                    }
-                    case "builtin/signin":
-                    case "builtin/signup": {
-                        const pkceSession = await this.core.then((core) => core.createPKCESession());
-                        this.setVerifierCookie(pkceSession.verifier);
-                        return (0, navigation_1.redirect)(params.auth[params.auth.length - 1] === "signup"
-                            ? pkceSession.getHostedUISignupUrl()
-                            : pkceSession.getHostedUISigninUrl());
-                    }
-                    case "signout": {
-                        if (!onSignout) {
-                            throw new auth_core_1.ConfigurationError(`'onSignout' auth route handler not configured`);
-                        }
-                        (0, headers_1.cookies)().delete(this.options.authCookieName);
-                        return onSignout(req);
-                    }
-                    default:
-                        return new Response("Unknown auth route", {
-                            status: 404,
-                        });
-                }
-            },
-            POST: async (req, { params }) => {
-                switch (params.auth.join("/")) {
-                    case "emailpassword/signin": {
-                        const data = await _getReqBody(req);
-                        const isAction = _isAction(data);
-                        if (!isAction && !onEmailPasswordSignIn) {
-                            throw new auth_core_1.ConfigurationError(`'onEmailPasswordSignIn' auth route handler not configured`);
-                        }
-                        let tokenData;
-                        try {
-                            const [email, password] = _extractParams(data, ["email", "password"], "email or password missing from request body");
-                            tokenData = await (await this.core).signinWithEmailPassword(email, password);
-                        }
-                        catch (err) {
-                            const error = err instanceof Error ? err : new Error(String(err));
-                            return onEmailPasswordSignIn
-                                ? _wrapResponse(onEmailPasswordSignIn({ error }, req), isAction)
-                                : Response.json(_wrapError(error));
-                        }
-                        this.setAuthCookie(tokenData.auth_token);
-                        return _wrapResponse(onEmailPasswordSignIn?.({ error: null, tokenData }, req), isAction);
-                    }
-                    case "emailpassword/signup": {
-                        const data = await _getReqBody(req);
-                        const isAction = _isAction(data);
-                        if (!isAction && !onEmailPasswordSignUp) {
-                            throw new auth_core_1.ConfigurationError(`'onEmailPasswordSignUp' auth route handler not configured`);
-                        }
-                        let result;
-                        try {
-                            const [email, password] = _extractParams(data, ["email", "password"], "email or password missing from request body");
-                            result = await (await this.core).signupWithEmailPassword(email, password, `${this._authRoute}/emailpassword/verify`);
-                        }
-                        catch (err) {
-                            const error = err instanceof Error ? err : new Error(String(err));
-                            return onEmailPasswordSignUp
-                                ? _wrapResponse(onEmailPasswordSignUp({ error }, req), isAction)
-                                : Response.json(_wrapError(error));
-                        }
-                        this.setVerifierCookie(result.verifier);
-                        if (result.status === "complete") {
-                            this.setAuthCookie(result.tokenData.auth_token);
-                            return _wrapResponse(onEmailPasswordSignUp?.({
-                                error: null,
-                                tokenData: result.tokenData,
-                            }, req), isAction);
-                        }
-                        else {
-                            return _wrapResponse(onEmailPasswordSignUp?.({ error: null, tokenData: null }, req), isAction);
-                        }
-                    }
-                    case "emailpassword/send-reset-email": {
-                        if (!this.options.passwordResetPath) {
-                            throw new auth_core_1.ConfigurationError(`'passwordResetPath' option not configured`);
-                        }
-                        const data = await _getReqBody(req);
-                        const isAction = _isAction(data);
-                        const [email] = _extractParams(data, ["email"], "email missing from request body");
-                        const { verifier } = await (await this.core).sendPasswordResetEmail(email, new URL(this.options.passwordResetPath, this.options.baseUrl).toString());
-                        this.setVerifierCookie(verifier);
-                        return isAction
-                            ? Response.json({ _data: null })
-                            : new Response(null, { status: 204 });
-                    }
-                    case "emailpassword/reset-password": {
-                        const data = await _getReqBody(req);
-                        const isAction = _isAction(data);
-                        if (!isAction && !onEmailPasswordReset) {
-                            throw new auth_core_1.ConfigurationError(`'onEmailPasswordReset' auth route handler not configured`);
-                        }
-                        let tokenData;
-                        try {
-                            const verifier = req.cookies.get(this.options.pkceVerifierCookieName)?.value;
-                            if (!verifier) {
-                                throw new auth_core_1.PKCEError("no pkce verifier cookie found");
-                            }
-                            const [resetToken, password] = _extractParams(data, ["reset_token", "password"], "reset_token or password missing from request body");
-                            tokenData = await (await this.core).resetPasswordWithResetToken(resetToken, verifier, password);
-                        }
-                        catch (err) {
-                            const error = err instanceof Error ? err : new Error(String(err));
-                            return onEmailPasswordReset
-                                ? _wrapResponse(onEmailPasswordReset({ error }, req), isAction)
-                                : Response.json(_wrapError(error));
-                        }
-                        this.setAuthCookie(tokenData.auth_token);
-                        (0, headers_1.cookies)().delete(this.options.pkceVerifierCookieName);
-                        return _wrapResponse(onEmailPasswordReset?.({ error: null, tokenData }, req), isAction);
-                    }
-                    case "emailpassword/resend-verification-email": {
-                        const data = await _getReqBody(req);
-                        const isAction = _isAction(data);
-                        const verificationToken = data instanceof FormData
-                            ? data.get("verification_token")?.toString()
-                            : data.verification_token;
-                        const email = data instanceof FormData
-                            ? data.get("email")?.toString()
-                            : data.email;
-                        if (verificationToken) {
-                            await (await this.core).resendVerificationEmail(verificationToken.toString());
-                            return isAction
-                                ? Response.json({ _data: null })
-                                : new Response(null, { status: 204 });
-                        }
-                        else if (email) {
-                            const { verifier } = await (await this.core).resendVerificationEmailForEmail(email.toString(), `${this._authRoute}/emailpassword/verify`);
-                            (0, headers_1.cookies)().set({
-                                name: this.options.pkceVerifierCookieName,
-                                value: verifier,
-                                httpOnly: true,
-                                sameSite: "strict",
-                                path: "/",
-                            });
-                            return isAction
-                                ? Response.json({ _data: null })
-                                : new Response(null, { status: 204 });
-                        }
-                        else {
-                            throw new auth_core_1.InvalidDataError("verification_token or email missing from request body");
-                        }
-                    }
-                    case "webauthn/signup": {
-                        if (!onWebAuthnSignUp) {
-                            throw new auth_core_1.ConfigurationError(`'onWebAuthnSignUp' auth route handler not configured`);
-                        }
-                        const { email, credentials, verify_url, user_handle } = await req.json();
-                        let result;
-                        try {
-                            result = await (await this.core).signupWithWebAuthn(email, credentials, verify_url, user_handle);
-                        }
-                        catch (err) {
-                            const error = err instanceof Error ? err : new Error(String(err));
-                            return _wrapResponse(onWebAuthnSignUp({ error }, req), false);
-                        }
-                        this.setVerifierCookie(result.verifier);
-                        if (result.status === "complete") {
-                            this.setAuthCookie(result.tokenData.auth_token);
-                            return _wrapResponse(onWebAuthnSignUp({
-                                error: null,
-                                tokenData: result.tokenData,
-                            }, req), false);
-                        }
-                        else {
-                            return _wrapResponse(onWebAuthnSignUp({ error: null, tokenData: null }, req), false);
-                        }
-                    }
-                    case "webauthn/signin": {
-                        if (!onWebAuthnSignIn) {
-                            throw new auth_core_1.ConfigurationError(`'onWebAuthnSignIn' auth route handler not configured`);
-                        }
-                        const { email, assertion } = await req.json();
-                        let tokenData;
-                        try {
-                            tokenData = await (await this.core).signinWithWebAuthn(email, assertion);
-                        }
-                        catch (err) {
-                            const error = err instanceof Error ? err : new Error(String(err));
-                            return _wrapResponse(onWebAuthnSignIn({ error }, req), false);
-                        }
-                        this.setAuthCookie(tokenData.auth_token);
-                        return _wrapResponse(onWebAuthnSignIn({ error: null, tokenData }, req), false);
-                    }
-                    case "magiclink/signup": {
-                        if (!this.options.magicLinkFailurePath) {
-                            throw new auth_core_1.ConfigurationError(`'magicLinkFailurePath' option not configured`);
-                        }
-                        const data = await _getReqBody(req);
-                        const isAction = _isAction(data);
-                        const [email] = _extractParams(data, ["email"], "email missing from request body");
-                        const { verifier } = await (await this.core).signupWithMagicLink(email, `${this._authRoute}/magiclink/callback?isSignUp=true`, new URL(this.options.magicLinkFailurePath, this.options.baseUrl).toString());
-                        this.setVerifierCookie(verifier);
-                        return isAction
-                            ? Response.json({ _data: null })
-                            : new Response(null, { status: 204 });
-                    }
-                    case "magiclink/send": {
-                        if (!this.options.magicLinkFailurePath) {
-                            throw new auth_core_1.ConfigurationError(`'magicLinkFailurePath' option not configured`);
-                        }
-                        const data = await _getReqBody(req);
-                        const isAction = _isAction(data);
-                        const [email] = _extractParams(data, ["email"], "email missing from request body");
-                        const { verifier } = await (await this.core).signinWithMagicLink(email, `${this._authRoute}/magiclink/callback`, new URL(this.options.magicLinkFailurePath, this.options.baseUrl).toString());
-                        this.setVerifierCookie(verifier);
-                        return isAction
-                            ? Response.json({ _data: null })
-                            : new Response(null, { status: 204 });
-                    }
-                    default:
-                        return new Response("Unknown auth route", {
-                            status: 404,
-                        });
-                }
-            },
-        };
+  client
+  core
+  constructor(client, options) {
+    super(options)
+    this.client = client
+    this.core = auth_core_1.Auth.create(client)
+  }
+  async getProvidersInfo() {
+    return (await this.core).getProvidersInfo()
+  }
+  isPasswordResetTokenValid(resetToken) {
+    return auth_core_1.Auth.checkPasswordResetTokenValid(resetToken)
+  }
+  async setVerifierCookie(verifier) {
+    const cookies = await (0, headers_1.cookies)()
+    cookies.set({
+      name: this.options.pkceVerifierCookieName,
+      value: verifier,
+      httpOnly: true,
+      path: '/',
+      sameSite: 'lax',
+      secure: this.isSecure,
+      expires: Date.now() + 1000 * 60 * 60 * 24 * 7,
+    })
+  }
+  async setAuthCookie(token) {
+    const expirationDate = auth_core_1.Auth.getTokenExpiration(token)
+    const cookies = await (0, headers_1.cookies)()
+    cookies.set({
+      name: this.options.authCookieName,
+      value: token,
+      httpOnly: true,
+      sameSite: 'lax',
+      path: '/',
+      secure: this.isSecure,
+      expires: expirationDate ?? undefined,
+    })
+  }
+  createAuthRouteHandlers({
+    onOAuthCallback,
+    onEmailPasswordSignIn,
+    onEmailPasswordSignUp,
+    onEmailPasswordReset,
+    onEmailVerify,
+    onWebAuthnSignUp,
+    onWebAuthnSignIn,
+    onMagicLinkCallback,
+    onBuiltinUICallback,
+    onSignout,
+  }) {
+    return {
+      GET: async (req, { params }) => {
+        switch (params.auth.join('/')) {
+          case 'oauth': {
+            if (!onOAuthCallback) {
+              throw new auth_core_1.ConfigurationError(
+                `'onOAuthCallback' auth route handler not configured`
+              )
+            }
+            const provider = req.nextUrl.searchParams.get('provider_name')
+            if (
+              !provider ||
+              !auth_core_1.builtinOAuthProviderNames.includes(provider)
+            ) {
+              throw new auth_core_1.InvalidDataError(
+                `invalid provider_name: ${provider}`
+              )
+            }
+            const redirectUrl = `${this._authRoute}/oauth/callback`
+            const pkceSession = await this.core.then((core) =>
+              core.createPKCESession()
+            )
+            await this.setVerifierCookie(pkceSession.verifier)
+            return (0, navigation_1.redirect)(
+              pkceSession.getOAuthUrl(
+                provider,
+                redirectUrl,
+                `${redirectUrl}?isSignUp=true`
+              )
+            )
+          }
+          case 'oauth/callback': {
+            if (!onOAuthCallback) {
+              throw new auth_core_1.ConfigurationError(
+                `'onOAuthCallback' auth route handler not configured`
+              )
+            }
+            const error = req.nextUrl.searchParams.get('error')
+            if (error) {
+              const desc = req.nextUrl.searchParams.get('error_description')
+              return onOAuthCallback(
+                {
+                  error: new auth_core_1.OAuthProviderFailureError(
+                    error + (desc ? `: ${desc}` : '')
+                  ),
+                },
+                req
+              )
+            }
+            const code = req.nextUrl.searchParams.get('code')
+            const isSignUp = req.nextUrl.searchParams.get('isSignUp') === 'true'
+            const verifier = req.cookies.get(
+              this.options.pkceVerifierCookieName
+            )?.value
+            if (!code) {
+              return onOAuthCallback(
+                {
+                  error: new auth_core_1.PKCEError('no pkce code in response'),
+                },
+                req
+              )
+            }
+            if (!verifier) {
+              return onOAuthCallback(
+                {
+                  error: new auth_core_1.PKCEError(
+                    'no pkce verifier cookie found'
+                  ),
+                },
+                req
+              )
+            }
+            let tokenData
+            try {
+              tokenData = await (await this.core).getToken(code, verifier)
+            } catch (err) {
+              return onOAuthCallback(
+                {
+                  error: err instanceof Error ? err : new Error(String(err)),
+                },
+                req
+              )
+            }
+            await this.setAuthCookie(tokenData.auth_token)
+            const cookies = await (0, headers_1.cookies)()
+            cookies.delete(this.options.pkceVerifierCookieName)
+            return onOAuthCallback(
+              {
+                error: null,
+                tokenData,
+                provider: req.nextUrl.searchParams.get('provider'),
+                isSignUp,
+              },
+              req
+            )
+          }
+          case 'emailpassword/verify': {
+            if (!onEmailVerify) {
+              throw new auth_core_1.ConfigurationError(
+                `'onEmailVerify' auth route handler not configured`
+              )
+            }
+            const verificationToken =
+              req.nextUrl.searchParams.get('verification_token')
+            const verifier = req.cookies.get(
+              this.options.pkceVerifierCookieName
+            )?.value
+            if (!verificationToken) {
+              return onEmailVerify(
+                {
+                  error: new auth_core_1.PKCEError(
+                    'no verification_token in response'
+                  ),
+                },
+                req
+              )
+            }
+            if (!verifier) {
+              return onEmailVerify(
+                {
+                  error: new auth_core_1.PKCEError(
+                    'no pkce verifier cookie found'
+                  ),
+                  verificationToken,
+                },
+                req
+              )
+            }
+            let tokenData
+            try {
+              tokenData = await (
+                await this.core
+              ).verifyEmailPasswordSignup(verificationToken, verifier)
+            } catch (err) {
+              return onEmailVerify(
+                {
+                  error: err instanceof Error ? err : new Error(String(err)),
+                  verificationToken,
+                },
+                req
+              )
+            }
+            await this.setAuthCookie(tokenData.auth_token)
+            const cookies = await (0, headers_1.cookies)()
+            cookies.delete(this.options.pkceVerifierCookieName)
+            return onEmailVerify({ error: null, tokenData }, req)
+          }
+          case 'webauthn/signup/options': {
+            const email = req.nextUrl.searchParams.get('email')
+            if (!email) {
+              throw new auth_core_1.InvalidDataError(
+                "'email' is missing in request search parameters"
+              )
+            }
+            return Response.redirect(
+              (await this.core).getWebAuthnSignupOptionsUrl(email)
+            )
+          }
+          case 'webauthn/signin/options': {
+            const email = req.nextUrl.searchParams.get('email')
+            if (!email) {
+              throw new auth_core_1.InvalidDataError(
+                "'email' is missing in request search parameters"
+              )
+            }
+            return Response.redirect(
+              (await this.core).getWebAuthnSigninOptionsUrl(email)
+            )
+          }
+          case 'webauthn/verify': {
+            if (!onEmailVerify) {
+              throw new auth_core_1.ConfigurationError(
+                `'onEmailVerify' auth route handler not configured`
+              )
+            }
+            const verificationToken =
+              req.nextUrl.searchParams.get('verification_token')
+            const verifier = req.cookies.get(
+              this.options.pkceVerifierCookieName
+            )?.value
+            if (!verificationToken) {
+              return onEmailVerify(
+                {
+                  error: new auth_core_1.PKCEError(
+                    'no verification_token in response'
+                  ),
+                },
+                req
+              )
+            }
+            if (!verifier) {
+              return onEmailVerify(
+                {
+                  error: new auth_core_1.PKCEError(
+                    'no pkce verifier cookie found'
+                  ),
+                  verificationToken,
+                },
+                req
+              )
+            }
+            let tokenData
+            try {
+              tokenData = await (
+                await this.core
+              ).verifyWebAuthnSignup(verificationToken, verifier)
+            } catch (err) {
+              return onEmailVerify(
+                {
+                  error: err instanceof Error ? err : new Error(String(err)),
+                  verificationToken,
+                },
+                req
+              )
+            }
+            await this.setAuthCookie(tokenData.auth_token)
+            const cookies = await (0, headers_1.cookies)()
+            cookies.delete(this.options.pkceVerifierCookieName)
+            return onEmailVerify({ error: null, tokenData }, req)
+          }
+          case 'magiclink/callback': {
+            if (!onMagicLinkCallback) {
+              throw new auth_core_1.ConfigurationError(
+                `'onMagicLinkCallback' auth route handler not configured`
+              )
+            }
+            const error = req.nextUrl.searchParams.get('error')
+            if (error) {
+              const desc = req.nextUrl.searchParams.get('error_description')
+              return onMagicLinkCallback(
+                {
+                  error: new auth_core_1.OAuthProviderFailureError(
+                    error + (desc ? `: ${desc}` : '')
+                  ),
+                },
+                req
+              )
+            }
+            const code = req.nextUrl.searchParams.get('code')
+            const isSignUp = req.nextUrl.searchParams.get('isSignUp') === 'true'
+            const verifier = req.cookies.get(
+              this.options.pkceVerifierCookieName
+            )?.value
+            if (!code) {
+              return onMagicLinkCallback(
+                {
+                  error: new auth_core_1.PKCEError('no pkce code in response'),
+                },
+                req
+              )
+            }
+            if (!verifier) {
+              return onMagicLinkCallback(
+                {
+                  error: new auth_core_1.PKCEError(
+                    'no pkce verifier cookie found'
+                  ),
+                },
+                req
+              )
+            }
+            let tokenData
+            try {
+              tokenData = await (await this.core).getToken(code, verifier)
+            } catch (err) {
+              return onMagicLinkCallback(
+                {
+                  error: err instanceof Error ? err : new Error(String(err)),
+                },
+                req
+              )
+            }
+            await this.setAuthCookie(tokenData.auth_token)
+            const cookies = await (0, headers_1.cookies)()
+            cookies.delete(this.options.pkceVerifierCookieName)
+            return onMagicLinkCallback(
+              {
+                error: null,
+                tokenData,
+                isSignUp,
+              },
+              req
+            )
+          }
+          case 'builtin/callback': {
+            if (!onBuiltinUICallback) {
+              throw new auth_core_1.ConfigurationError(
+                `'onBuiltinUICallback' auth route handler not configured`
+              )
+            }
+            const error = req.nextUrl.searchParams.get('error')
+            if (error) {
+              const desc = req.nextUrl.searchParams.get('error_description')
+              return onBuiltinUICallback(
+                {
+                  error: new auth_core_1.EdgeDBAuthError(
+                    error + (desc ? `: ${desc}` : '')
+                  ),
+                },
+                req
+              )
+            }
+            const code = req.nextUrl.searchParams.get('code')
+            const verificationEmailSentAt = req.nextUrl.searchParams.get(
+              'verification_email_sent_at'
+            )
+            if (!code) {
+              if (verificationEmailSentAt) {
+                return onBuiltinUICallback(
+                  {
+                    error: null,
+                    tokenData: null,
+                    provider: null,
+                    isSignUp: true,
+                  },
+                  req
+                )
+              }
+              return onBuiltinUICallback(
+                {
+                  error: new auth_core_1.PKCEError('no pkce code in response'),
+                },
+                req
+              )
+            }
+            const verifier = req.cookies.get(
+              this.options.pkceVerifierCookieName
+            )?.value
+            if (!verifier) {
+              return onBuiltinUICallback(
+                {
+                  error: new auth_core_1.PKCEError(
+                    'no pkce verifier cookie found'
+                  ),
+                },
+                req
+              )
+            }
+            const isSignUp = req.nextUrl.searchParams.get('isSignUp') === 'true'
+            let tokenData
+            try {
+              tokenData = await (await this.core).getToken(code, verifier)
+            } catch (err) {
+              return onBuiltinUICallback(
+                {
+                  error: err instanceof Error ? err : new Error(String(err)),
+                },
+                req
+              )
+            }
+            await this.setAuthCookie(tokenData.auth_token)
+            return onBuiltinUICallback(
+              {
+                error: null,
+                tokenData,
+                provider: req.nextUrl.searchParams.get('provider'),
+                isSignUp,
+              },
+              req
+            )
+          }
+          case 'builtin/signin':
+          case 'builtin/signup': {
+            const pkceSession = await this.core.then((core) =>
+              core.createPKCESession()
+            )
+            await this.setVerifierCookie(pkceSession.verifier)
+            return (0, navigation_1.redirect)(
+              params.auth[params.auth.length - 1] === 'signup'
+                ? pkceSession.getHostedUISignupUrl()
+                : pkceSession.getHostedUISigninUrl()
+            )
+          }
+          case 'signout': {
+            if (!onSignout) {
+              throw new auth_core_1.ConfigurationError(
+                `'onSignout' auth route handler not configured`
+              )
+            }
+            const cookies = await (0, headers_1.cookies)()
+            cookies.delete(this.options.authCookieName)
+            return onSignout(req)
+          }
+          default:
+            return new Response('Unknown auth route', {
+              status: 404,
+            })
+        }
+      },
+      POST: async (req, { params }) => {
+        switch (params.auth.join('/')) {
+          case 'emailpassword/signin': {
+            const data = await _getReqBody(req)
+            const isAction = _isAction(data)
+            if (!isAction && !onEmailPasswordSignIn) {
+              throw new auth_core_1.ConfigurationError(
+                `'onEmailPasswordSignIn' auth route handler not configured`
+              )
+            }
+            let tokenData
+            try {
+              const [email, password] = _extractParams(
+                data,
+                ['email', 'password'],
+                'email or password missing from request body'
+              )
+              tokenData = await (
+                await this.core
+              ).signinWithEmailPassword(email, password)
+            } catch (err) {
+              const error = err instanceof Error ? err : new Error(String(err))
+              return onEmailPasswordSignIn
+                ? _wrapResponse(onEmailPasswordSignIn({ error }, req), isAction)
+                : Response.json(_wrapError(error))
+            }
+            await this.setAuthCookie(tokenData.auth_token)
+            return _wrapResponse(
+              onEmailPasswordSignIn?.({ error: null, tokenData }, req),
+              isAction
+            )
+          }
+          case 'emailpassword/signup': {
+            const data = await _getReqBody(req)
+            const isAction = _isAction(data)
+            if (!isAction && !onEmailPasswordSignUp) {
+              throw new auth_core_1.ConfigurationError(
+                `'onEmailPasswordSignUp' auth route handler not configured`
+              )
+            }
+            let result
+            try {
+              const [email, password] = _extractParams(
+                data,
+                ['email', 'password'],
+                'email or password missing from request body'
+              )
+              result = await (
+                await this.core
+              ).signupWithEmailPassword(
+                email,
+                password,
+                `${this._authRoute}/emailpassword/verify`
+              )
+            } catch (err) {
+              const error = err instanceof Error ? err : new Error(String(err))
+              return onEmailPasswordSignUp
+                ? _wrapResponse(onEmailPasswordSignUp({ error }, req), isAction)
+                : Response.json(_wrapError(error))
+            }
+            await this.setVerifierCookie(result.verifier)
+            if (result.status === 'complete') {
+              await this.setAuthCookie(result.tokenData.auth_token)
+              return _wrapResponse(
+                onEmailPasswordSignUp?.(
+                  {
+                    error: null,
+                    tokenData: result.tokenData,
+                  },
+                  req
+                ),
+                isAction
+              )
+            } else {
+              return _wrapResponse(
+                onEmailPasswordSignUp?.({ error: null, tokenData: null }, req),
+                isAction
+              )
+            }
+          }
+          case 'emailpassword/send-reset-email': {
+            if (!this.options.passwordResetPath) {
+              throw new auth_core_1.ConfigurationError(
+                `'passwordResetPath' option not configured`
+              )
+            }
+            const data = await _getReqBody(req)
+            const isAction = _isAction(data)
+            const [email] = _extractParams(
+              data,
+              ['email'],
+              'email missing from request body'
+            )
+            const { verifier } = await (
+              await this.core
+            ).sendPasswordResetEmail(
+              email,
+              new URL(
+                this.options.passwordResetPath,
+                this.options.baseUrl
+              ).toString()
+            )
+            await this.setVerifierCookie(verifier)
+            return isAction
+              ? Response.json({ _data: null })
+              : new Response(null, { status: 204 })
+          }
+          case 'emailpassword/reset-password': {
+            const data = await _getReqBody(req)
+            const isAction = _isAction(data)
+            if (!isAction && !onEmailPasswordReset) {
+              throw new auth_core_1.ConfigurationError(
+                `'onEmailPasswordReset' auth route handler not configured`
+              )
+            }
+            let tokenData
+            try {
+              const verifier = req.cookies.get(
+                this.options.pkceVerifierCookieName
+              )?.value
+              if (!verifier) {
+                throw new auth_core_1.PKCEError('no pkce verifier cookie found')
+              }
+              const [resetToken, password] = _extractParams(
+                data,
+                ['reset_token', 'password'],
+                'reset_token or password missing from request body'
+              )
+              tokenData = await (
+                await this.core
+              ).resetPasswordWithResetToken(resetToken, verifier, password)
+            } catch (err) {
+              const error = err instanceof Error ? err : new Error(String(err))
+              return onEmailPasswordReset
+                ? _wrapResponse(onEmailPasswordReset({ error }, req), isAction)
+                : Response.json(_wrapError(error))
+            }
+            await this.setAuthCookie(tokenData.auth_token)
+            const cookies = await (0, headers_1.cookies)()
+            cookies.delete(this.options.pkceVerifierCookieName)
+            return _wrapResponse(
+              onEmailPasswordReset?.({ error: null, tokenData }, req),
+              isAction
+            )
+          }
+          case 'emailpassword/resend-verification-email': {
+            const data = await _getReqBody(req)
+            const isAction = _isAction(data)
+            const verificationToken =
+              data instanceof FormData
+                ? data.get('verification_token')?.toString()
+                : data.verification_token
+            const email =
+              data instanceof FormData
+                ? data.get('email')?.toString()
+                : data.email
+            if (verificationToken) {
+              await (
+                await this.core
+              ).resendVerificationEmail(verificationToken.toString())
+              return isAction
+                ? Response.json({ _data: null })
+                : new Response(null, { status: 204 })
+            } else if (email) {
+              const { verifier } = await (
+                await this.core
+              ).resendVerificationEmailForEmail(
+                email.toString(),
+                `${this._authRoute}/emailpassword/verify`
+              )
+              const cookies = await (0, headers_1.cookies)()
+              cookies.set({
+                name: this.options.pkceVerifierCookieName,
+                value: verifier,
+                httpOnly: true,
+                sameSite: 'strict',
+                path: '/',
+              })
+              return isAction
+                ? Response.json({ _data: null })
+                : new Response(null, { status: 204 })
+            } else {
+              throw new auth_core_1.InvalidDataError(
+                'verification_token or email missing from request body'
+              )
+            }
+          }
+          case 'webauthn/signup': {
+            if (!onWebAuthnSignUp) {
+              throw new auth_core_1.ConfigurationError(
+                `'onWebAuthnSignUp' auth route handler not configured`
+              )
+            }
+            const { email, credentials, verify_url, user_handle } =
+              await req.json()
+            let result
+            try {
+              result = await (
+                await this.core
+              ).signupWithWebAuthn(email, credentials, verify_url, user_handle)
+            } catch (err) {
+              const error = err instanceof Error ? err : new Error(String(err))
+              return _wrapResponse(onWebAuthnSignUp({ error }, req), false)
+            }
+            await this.setVerifierCookie(result.verifier)
+            if (result.status === 'complete') {
+              await this.setAuthCookie(result.tokenData.auth_token)
+              return _wrapResponse(
+                onWebAuthnSignUp(
+                  {
+                    error: null,
+                    tokenData: result.tokenData,
+                  },
+                  req
+                ),
+                false
+              )
+            } else {
+              return _wrapResponse(
+                onWebAuthnSignUp({ error: null, tokenData: null }, req),
+                false
+              )
+            }
+          }
+          case 'webauthn/signin': {
+            if (!onWebAuthnSignIn) {
+              throw new auth_core_1.ConfigurationError(
+                `'onWebAuthnSignIn' auth route handler not configured`
+              )
+            }
+            const { email, assertion } = await req.json()
+            let tokenData
+            try {
+              tokenData = await (
+                await this.core
+              ).signinWithWebAuthn(email, assertion)
+            } catch (err) {
+              const error = err instanceof Error ? err : new Error(String(err))
+              return _wrapResponse(onWebAuthnSignIn({ error }, req), false)
+            }
+            await this.setAuthCookie(tokenData.auth_token)
+            return _wrapResponse(
+              onWebAuthnSignIn({ error: null, tokenData }, req),
+              false
+            )
+          }
+          case 'magiclink/signup': {
+            if (!this.options.magicLinkFailurePath) {
+              throw new auth_core_1.ConfigurationError(
+                `'magicLinkFailurePath' option not configured`
+              )
+            }
+            const data = await _getReqBody(req)
+            const isAction = _isAction(data)
+            const [email] = _extractParams(
+              data,
+              ['email'],
+              'email missing from request body'
+            )
+            const { verifier } = await (
+              await this.core
+            ).signupWithMagicLink(
+              email,
+              `${this._authRoute}/magiclink/callback?isSignUp=true`,
+              new URL(
+                this.options.magicLinkFailurePath,
+                this.options.baseUrl
+              ).toString()
+            )
+            await this.setVerifierCookie(verifier)
+            return isAction
+              ? Response.json({ _data: null })
+              : new Response(null, { status: 204 })
+          }
+          case 'magiclink/send': {
+            if (!this.options.magicLinkFailurePath) {
+              throw new auth_core_1.ConfigurationError(
+                `'magicLinkFailurePath' option not configured`
+              )
+            }
+            const data = await _getReqBody(req)
+            const isAction = _isAction(data)
+            const [email] = _extractParams(
+              data,
+              ['email'],
+              'email missing from request body'
+            )
+            const { verifier } = await (
+              await this.core
+            ).signinWithMagicLink(
+              email,
+              `${this._authRoute}/magiclink/callback`,
+              new URL(
+                this.options.magicLinkFailurePath,
+                this.options.baseUrl
+              ).toString()
+            )
+            await this.setVerifierCookie(verifier)
+            return isAction
+              ? Response.json({ _data: null })
+              : new Response(null, { status: 204 })
+          }
+          default:
+            return new Response('Unknown auth route', {
+              status: 404,
+            })
+        }
+      },
     }
+  }
 }
-exports.NextAuth = NextAuth;
+exports.NextAuth = NextAuth
 class NextAuthSession {
-    authToken;
-    client;
-    constructor(client, authToken) {
-        this.authToken = authToken;
-        this.client = this.authToken
-            ? client.withGlobals({ "ext::auth::client_token": this.authToken })
-            : client;
-    }
-    _isSignedIn = null;
-    async isSignedIn() {
-        if (!this.authToken)
-            return false;
-        return (this._isSignedIn ??
-            (this._isSignedIn = this.client
-                .queryRequiredSingle(`select exists global ext::auth::ClientTokenIdentity`)
-                .catch(() => false)));
-    }
+  authToken
+  client
+  constructor(client, authToken) {
+    this.authToken = authToken
+    this.client = this.authToken
+      ? client.withGlobals({ 'ext::auth::client_token': this.authToken })
+      : client
+  }
+  _isSignedIn = null
+  async isSignedIn() {
+    if (!this.authToken) return false
+    return (
+      this._isSignedIn ??
+      (this._isSignedIn = this.client
+        .queryRequiredSingle(
+          `select exists global ext::auth::ClientTokenIdentity`
+        )
+        .catch(() => false))
+    )
+  }
 }
-exports.NextAuthSession = NextAuthSession;
+exports.NextAuthSession = NextAuthSession
 function _getReqBody(req) {
-    return req.headers.get("Content-Type") === "application/json"
-        ? req.json()
-        : req.formData();
+  return req.headers.get('Content-Type') === 'application/json'
+    ? req.json()
+    : req.formData()
 }
 function _isAction(data) {
-    return typeof data === "object" && data._action === true;
+  return typeof data === 'object' && data._action === true
 }
 function _extractParams(data, paramNames, errMessage) {
-    const params = [];
-    if (data instanceof FormData) {
-        for (const paramName of paramNames) {
-            const param = data.get(paramName)?.toString();
-            if (!param) {
-                throw new auth_core_1.InvalidDataError(errMessage);
-            }
-            params.push(param);
-        }
+  const params = []
+  if (data instanceof FormData) {
+    for (const paramName of paramNames) {
+      const param = data.get(paramName)?.toString()
+      if (!param) {
+        throw new auth_core_1.InvalidDataError(errMessage)
+      }
+      params.push(param)
     }
-    else {
-        if (typeof data !== "object") {
-            throw new auth_core_1.InvalidDataError("expected json object");
-        }
-        for (const paramName of paramNames) {
-            const param = data[paramName];
-            if (!param) {
-                throw new auth_core_1.InvalidDataError(errMessage);
-            }
-            if (typeof param !== "string") {
-                throw new auth_core_1.InvalidDataError(`expected '${paramName}' to be a string`);
-            }
-            params.push(param);
-        }
+  } else {
+    if (typeof data !== 'object') {
+      throw new auth_core_1.InvalidDataError('expected json object')
+    }
+    for (const paramName of paramNames) {
+      const param = data[paramName]
+      if (!param) {
+        throw new auth_core_1.InvalidDataError(errMessage)
+      }
+      if (typeof param !== 'string') {
+        throw new auth_core_1.InvalidDataError(
+          `expected '${paramName}' to be a string`
+        )
+      }
+      params.push(param)
     }
-    return params;
+  }
+  return params
 }
 function _wrapResponse(res, isAction) {
-    if (isAction) {
-        return (res
-            ?.then(async (res) => Response.json({ _data: await res.json() }))
-            .catch((err) => {
-            return Response.json(_isRedirect(err) || _wrapError(err));
-        }) ?? Response.json({ _data: null }));
-    }
-    return res;
+  if (isAction) {
+    return (
+      res
+        ?.then(async (res) => Response.json({ _data: await res.json() }))
+        .catch((err) => {
+          return Response.json(_isRedirect(err) || _wrapError(err))
+        }) ?? Response.json({ _data: null })
+    )
+  }
+  return res
 }
 function _wrapError(err) {
-    return {
-        _error: {
-            type: err instanceof auth_core_1.EdgeDBAuthError ? err.type : null,
-            message: err instanceof Error ? err.message : String(err),
-        },
-    };
+  return {
+    _error: {
+      type: err instanceof auth_core_1.EdgeDBAuthError ? err.type : null,
+      message: err instanceof Error ? err.message : String(err),
+    },
+  }
 }
 function _isRedirect(error) {
-    if (!(error instanceof Error) ||
-        error.message !== "NEXT_REDIRECT" ||
-        typeof error.digest !== "string") {
-        return false;
-    }
-    const [_, type, location] = error.digest.split(";");
-    return { _redirect: { location, replace: type === "replace" } };
+  if (
+    !(error instanceof Error) ||
+    error.message !== 'NEXT_REDIRECT' ||
+    typeof error.digest !== 'string'
+  ) {
+    return false
+  }
+  const [_, type, location] = error.digest.split(';')
+  return { _redirect: { location, replace: type === 'replace' } }
 }
