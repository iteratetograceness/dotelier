'use server'

import { readFile } from 'fs/promises'
import { join } from 'path'
import { GEMINI_REFERENCE_IMAGES, GEMINI_SYSTEM_PROMPT } from '@/lib/constants'
import { gemini, GEMINI_MODEL } from '@/lib/gemini'
import { getPublicPixelAsset } from '@/lib/ut/client'
import { uploadApi } from '@/lib/ut/server'
import type { PixelApiResponse } from './types'

async function loadLocalImage(
  relativePath: string
): Promise<{ base64: string; mimeType: string }> {
  const fullPath = join(process.cwd(), 'public', relativePath)
  const buffer = await readFile(fullPath)
  const base64 = buffer.toString('base64')
  // Determine mime type from extension
  const ext = relativePath.split('.').pop()?.toLowerCase()
  const mimeType = ext === 'png' ? 'image/png' : ext === 'jpg' || ext === 'jpeg' ? 'image/jpeg' : 'image/png'
  return { base64, mimeType }
}

// 90 second timeout for image generation
const GENERATION_TIMEOUT_MS = 90_000

function withTimeout<T>(promise: Promise<T>, ms: number): Promise<T> {
  return Promise.race([
    promise,
    new Promise<never>((_, reject) =>
      setTimeout(() => reject(new Error('Image generation timed out')), ms)
    ),
  ])
}

export async function generateWithGemini({
  prompt,
  pixelId,
}: {
  prompt: string
  pixelId: string
}): Promise<PixelApiResponse> {
  const startTime = Date.now()

  console.log('[generateWithGemini] Starting generation for:', prompt)
  console.log('[generateWithGemini] Reference images count:', GEMINI_REFERENCE_IMAGES.length)

  // Load local reference images
  const referenceImages = await Promise.all(
    GEMINI_REFERENCE_IMAGES.map(loadLocalImage)
  )
  console.log(`[generateWithGemini] Loaded ${referenceImages.length} reference images`)

  // Build multimodal content parts
  const parts: Array<
    | { text: string }
    | { inlineData: { mimeType: string; data: string } }
  > = [
    { text: GEMINI_SYSTEM_PROMPT },
    { text: '\n\nReference images showing the exact pixel art style to replicate:' },
  ]

  // Add reference images
  for (const img of referenceImages) {
    parts.push({
      inlineData: {
        mimeType: img.mimeType,
        data: img.base64,
      },
    })
  }

  // Add user prompt
  parts.push({
    text: `\n\nNow create a tiny pixel art icon of: ${prompt}\n\nRemember: MATCH THE REFERENCE IMAGES EXACTLY - same low resolution, same simple blocky style, same level of detail.`,
  })

  // Call Gemini API with timeout
  console.log('[generateWithGemini] Calling Gemini API...')
  const response = await withTimeout(
    gemini.models.generateContent({
      model: GEMINI_MODEL,
      contents: [{ role: 'user', parts }],
      config: {
        responseModalities: ['TEXT', 'IMAGE'],
        imageConfig: {
          aspectRatio: '1:1',
        },
      },
    }),
    GENERATION_TIMEOUT_MS
  )
  console.log('[generateWithGemini] Gemini API response received')

  // Extract generated image from response
  const candidate = response.candidates?.[0]
  if (!candidate?.content?.parts) {
    throw new Error('No response from Gemini')
  }

  const imagePart = candidate.content.parts.find(
    (part) => part.inlineData?.mimeType?.startsWith('image/')
  )

  if (!imagePart?.inlineData) {
    throw new Error('No image generated by Gemini')
  }

  const imageBase64 = imagePart.inlineData.data
  if (!imageBase64) {
    throw new Error('Empty image data from Gemini')
  }

  // Convert base64 to File for upload
  const imageBuffer = Buffer.from(imageBase64, 'base64')
  const imageBlob = new Blob([imageBuffer], { type: 'image/png' })
  const imageFile = new File([imageBlob], `${pixelId}.png`, {
    type: 'image/png',
  })

  // Upload to UploadThing
  const uploadResult = await uploadApi.uploadFiles([imageFile])

  if (!uploadResult.length || uploadResult[0].error) {
    const error = uploadResult[0]?.error ?? 'Failed to upload generated image'
    throw new Error(String(error))
  }

  const fileKey = uploadResult[0].data.key
  const url = getPublicPixelAsset(fileKey)
  const inferenceTime = (Date.now() - startTime) / 1000

  return {
    images: [
      {
        base64: imageBase64,
        url,
        fileKey,
      },
    ],
    inference_time: inferenceTime,
  }
}
